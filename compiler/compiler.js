// Generated by CoffeeScript 2.6.1
(function() {
  //{encode} = require("./sourcemap-codec.js")
  var generate, isArray, isString, la, lanpa, log, logAll, logs, nameRegexA, nameRegexB, numRegexA, numRegexB, operatorRegex, pVal, parse, reservedWordRegex, run, seacow, tokenize, translate,
    indexOf = [].indexOf;

  log = console.log;

  logs = function(...x) {
    log(...x);
    return log('');
  };

  logAll = function(xs) {
    var i, len, x;
    for (i = 0, len = xs.length; i < len; i++) {
      x = xs[i];
      log(x);
    }
    return log('');
  };

  run = function(x) {
    return x();
  };

  //#########################################################################################
  la = '(?=[, :})#\\]]|\\n|$)'; // look ahead

  lanpa = '(?=[, })#\\]]|\\n|$)'; // look ahead - no prop access

  numRegexA = RegExp(`^[+-]?([0-9A-Z]+[.][0-9A-Z]+|[.][0-9A-Z]+|[0-9A-Z]+)/[0-9]+${la}`, "i");

  numRegexB = RegExp(`^[+-]?([0-9]+[.][0-9]+|[.][0-9]+|[0-9]+)${la}`);

  operatorRegex = RegExp(`^(==|!=|<=|>=|<<|>>|//|%%|::|is not|is|\\*\\*|[-+*/%=<>])${lanpa}`);

  reservedWordRegex = RegExp(`^(def|await|yield|outer|var|let|return|break|continue|comment|lang|default|while|until|loop|for|of|in|ever|if|unless|else|opt|alt|do|try|catch|finally)${lanpa}`);

  nameRegexA = RegExp(`^~?(@?[a-zA-Z_$][a-zA-Z0-9_$]*|&[a-zA-Z_$][a-zA-Z0-9_$]*|&[0-9]+|&&|&)([?]?:[a-zA-Z_$][a-zA-Z0-9_$]*)*[?!]?${la}`);

  nameRegexB = RegExp(`^([.:]?[a-zA-Z_$][a-zA-Z0-9_$]*)([?]?:[a-zA-Z_$][a-zA-Z0-9_$]*)*[?]?${la}`);

  //#########################################################################################
  tokenize = function(charStream, logMode) {
    var advance, eat, idx, indentStack, mode, scanToken, scanTokenBlock, tokenFuncs, tokenStream;
    if (charStream.split('\n')[0] === '[mode = literate]') {
      mode = 'literate';
    }
    tokenFuncs = {};
    scanToken = function(type, regex) {
      var res;
      res = charStream.slice(idx).match(regex);
      if (res === null) {
        return false;
      }
      eat({
        type,
        content: res[0]
      });
      return true;
    };
    scanTokenBlock = function(type, regex) {
      var baseIndent, idx2, isDedent, isNonEmpty, line, parts, whitespace;
      if (!charStream.slice(idx).match(regex)) {
        return false;
      }
      parts = [];
      idx2 = idx;
      line = charStream.slice(idx2).match(/^.*/);
      parts.push(line[0]);
      idx2 += line[0].length;
      //# find base indent level

      // match all whitespace between the end of the first line
      // and the first non-whitespace character.
      whitespace = charStream.slice(idx2).match(/^[ \n]*(?=[^ \n])/);
      // return if there is no next non-whitespace char (ie EOF)
      if (!whitespace) {
        //eat {type, content: parts[0]}
        return false; //true
      }
      baseIndent = whitespace[0].split('\n').at(-1).length;
      // return if first non-whitespace char is not indented.
      if (!(baseIndent > indentStack.at(-1))) {
        //eat {type, content: parts[0]}
        return false; //true
      }
      
        //# consume lines
      while (true) {
        line = charStream.slice(idx2).match(/^\n([ ]*)(.*)/);
        if (!line) {
          break;
        }
        isDedent = line[2].length > 0;
        isNonEmpty = line[1].length < baseIndent;
        if (isDedent && isNonEmpty) {
          break;
        }
        parts.push(line[0]);
        idx2 += line[0].length;
      }
      eat({
        type,
        content: parts.join('')
      });
      return true;
    };
    //#####################################################################################
    tokenFuncs.litComment = function() {
      var res;
      if (mode !== 'literate') {
        return false;
      }
      res = charStream.slice(idx).match(/^\n[^ \n].+/);
      if (!res) {
        return false;
      }
      eat({
        type: 'comment',
        content: res[0]
      });
      return true;
    };
    tokenFuncs.bool = function() {
      return scanToken('bool', "^true|false" + la);
    };
    tokenFuncs.reservedWord = function() {
      return scanToken('resWord', reservedWordRegex);
    };
    tokenFuncs.operator = function() {
      return scanToken('biOp', operatorRegex);
    };
    tokenFuncs.label = function() {
      return scanToken('label', '^/[a-zA-Z_$]+/' + lanpa);
    };
    tokenFuncs.comma = function() {
      return scanToken('comma', '^,' + lanpa);
    };
    tokenFuncs.wave = function() {
      return scanToken('wave', '^~' + la);
    };
    tokenFuncs.pipe = function() {
      return scanToken('pipe', '^\\|' + lanpa);
    };
    tokenFuncs.key = function() {
      return scanToken('key', '^[a-zA-Z][a-zA-Z0-9_$]*[:;]' + lanpa);
    };
    tokenFuncs.name = function() {
      return scanToken('name', nameRegexA);
    };
    tokenFuncs.tag = function() {
      return scanToken('tag', '^<(\\w+)(#\\w+)?(\\.\\w+)*>' + lanpa);
    };
    tokenFuncs.dotName = function() {
      return scanToken('dotName', nameRegexB);
    };
    tokenFuncs.thinArrow = function() {
      return scanToken('thinArrow', '^->' + lanpa);
    };
    tokenFuncs.fatArrow = function() {
      return scanToken('fatArrow', '^=>' + lanpa);
    };
    tokenFuncs.space = function() {
      return scanToken('space', '^[ ]+');
    };
    tokenFuncs.openParen = function() {
      return scanToken('openParen', '^\\(');
    };
    tokenFuncs.closeParen = function() {
      return scanToken('closeParen', '^\\)' + la);
    };
    tokenFuncs.openCurly = function() {
      return scanToken('openCurly', '^[{]');
    };
    tokenFuncs.closeCurly = function() {
      return scanToken('closeCurly', '^[}]' + la);
    };
    tokenFuncs.inlineComment = function() {
      return scanToken('comment', '^\\[.*\\]' + lanpa);
    };
    tokenFuncs.numberRadix = function() {
      return scanToken('number', numRegexA);
    };
    tokenFuncs.numberSep = function() {
      return scanToken('number', '^[0-9]{1,3}(_[0-9]{3})+' + la);
    };
    tokenFuncs.number = function() {
      return scanToken('number', numRegexB);
    };
    tokenFuncs.commentBlock = function() {
      return scanTokenBlock('comment', /^#/);
    };
    tokenFuncs.commentLine = function() {
      return scanToken('comment', /^#.*/);
    };
    tokenFuncs.arrowStringA = function() {
      return scanToken('string', /^~>[ ].*/);
    };
    tokenFuncs.arrowStringB = function() {
      return scanTokenBlock('blockString', /^~>(?![^ \n])/);
    };
    tokenFuncs.arrowStringC = function() {
      return scanToken('string', /^~>(?=\n)|^~>$/);
    };
    tokenFuncs.stringSingle = function() {
      return scanToken('string', RegExp(`^'[a-zA-Z0-9_-]*${lanpa}`));
    };
    tokenFuncs.stringDouble = function() {
      return scanToken('string', RegExp(`^"(?:\\\\.|[^"[])*"${la}`));
    };
    tokenFuncs.stringStart = function() {
      return scanToken('stringStart', RegExp(`^"(?:\\\\.|[^"[])*\\[${la}`));
    };
    tokenFuncs.stringMiddle = function() {
      return scanToken('stringMiddle', RegExp(`^](?:\\\\.|[^"[])*\\[${la}`));
    };
    tokenFuncs.stringEnd = function() {
      return scanToken('stringEnd', RegExp(`^](?:\\\\.|[^"[])*"${la}`));
    };
    tokenFuncs.endOfFile = function() {
      if (charStream.slice(idx) !== '') {
        return false;
      }
      while (indentStack.length > 1) {
        indentStack.pop();
        eat({
          type: 'newline',
          content: ''
        });
        eat({
          type: 'dedent',
          content: ''
        });
      }
      eat({
        type: 'EOF',
        content: ''
      });
      return true;
    };
    //#####################################################################################
    indentStack = [0];
    tokenFuncs.newLine = function() {
      var dedents, indent, previous, res;
      res = charStream.slice(idx).match(/^\n */);
      if (!res) {
        return false;
      }
      idx += res[0].length;
      indent = res[0].length - 1;
      previous = indentStack.at(-1);
      // don't change indent level for empty lines.
      if (charStream[idx] === '\n') {
        eat({
          type: 'emptyLine',
          content: ''
        });
      } else if (indent === previous) {
        eat({
          type: 'newline',
          content: ''
        });
      } else if (indent > previous) {
        indentStack.push(indent);
        eat({
          type: 'indent',
          content: ''
        });
      } else if (indent < previous) {
        if (indexOf.call(indentStack, indent) < 0) {
          throw 'Error: invalid dedent level';
        }
        dedents = indentStack.length - (indentStack.indexOf(indent)) - 1;
        eat({
          type: 'newline',
          content: ''
        });
        while (dedents-- > 0) {
          indentStack.pop();
          eat({
            type: 'dedent',
            content: ''
          });
          eat({
            type: 'newline',
            content: ''
          });
        }
      }
      return true;
    };
    //#####################################################################################
    eat = function(token) {
      //log token
      tokenStream.push(token);
      idx += token.content.length;
      return true;
    };
    tokenStream = [];
    idx = 0;
    advance = function() {
      var func, funcName;
      for (funcName in tokenFuncs) {
        func = tokenFuncs[funcName];
        if (func()) {
          return funcName !== 'endOfFile';
        }
      }
      throw 'ERROR: unable to identify token at index ' + idx + ':\n' + charStream.slice(idx).match(/^.*/);
    };
    while (advance()) {
      continue;
    }
    return tokenStream.filter(function(token) {
      var ref;
      return (ref = token.type) !== 'space' && ref !== 'comment' && ref !== 'emptyLine';
    });
  };

  //#########################################################################################
  parse = function(tokenStream) {
    var advance, blockTypes, canStartHead, checkName, endExpr, handleAwaitYield, handleScope, handleUpdate, hasArguments, idx, isAssignment, isDestructName, isParamName, isSimpleName, isVarName, makeStrict, nextToken, parseArgBlock, parseConditional, parseDeclaration, parseDef, parseDestruct, parseExpression, parseFatArrow, parseFor, parseHead, parseLet, parseLineFunction, parseLoopControl, parseObject, parseObjectBlock, parseOpt, parseParen, parsePipeAssign, parsePipeCall, parsePipeOp, parseReturn, parseStatementBlock, parseStringInterp, parseTag, parseTerminal, parseThrow, parseTry, parseValue, parseWhile, token, valueTypes;
    idx = 0;
    token = null;
    nextToken = null;
    advance = function() {
      token = tokenStream[idx++];
      return nextToken = tokenStream[idx];
    };
    advance();
    //#####################################################################################
    parseTerminal = function() {
      var res;
      res = token;
      advance();
      //log token
      return res;
    };
    //#####################################################################################
    endExpr = false;
    valueTypes = ['string', 'number', 'thinArrow', 'openCurly', 'stringStart', 'name', 'openParen', 'blockString', 'fatArrow', 'bool', 'tag'];
    blockTypes = ['blockString', 'fatArrow'];
    parseValue = function(options) {
      var canBeBlock, canBeUpdate, ref, ref1, ref2;
      ({canBeBlock, canBeUpdate} = options);
      if ((ref = token.type, indexOf.call(blockTypes, ref) >= 0) && (!canBeBlock)) {
        throw 'block not allowed here';
      }
      //lastValueWasBlock = token.type in blockTypes
      if (token.type === 'name') {
        if (token.content.endsWith('?')) {
          throw 'parseValue: illegal "?"';
        }
        if (canBeUpdate && token.content.startsWith('~')) {
          throw 'bad spread';
        }
        if ((!canBeUpdate) && token.content.endsWith('!')) {
          throw 'bad update';
        }
        return parseTerminal();
      } else if ((ref1 = token.type) === 'bool' || ref1 === 'number' || ref1 === 'string' || ref1 === 'blockString') {
        return parseTerminal();
      } else if (token.type === 'stringStart') {
        return parseStringInterp();
      } else if ((ref2 = token.type) === 'thinArrow' || ref2 === 'openCurly') {
        return parseLineFunction();
      } else if (token.type === 'fatArrow') {
        return parseFatArrow();
      } else if (token.type === 'openParen') {
        return parseParen();
      }
    };
    parseTag = function() {
      var classes, content, front, id, tag;
      logs(token.content);
      [front, ...classes] = token.content.slice(1, -1).split('.');
      [tag, id] = front.split('#');
      //logs 'tag:', tag
      //logs 'id:', id
      //logs 'classes:', ...classes
      content = [
        {
          type: 'name',
          content: '$tag'
        },
        {
          type: 'string',
          content: `~> ${token.content}`
        }
      ];
      parseTerminal();
      return content;
    };
    parseExpression = function(options) {
      var canBeBlock, content, mustBeHead, ref, ref1;
      ({mustBeHead, canBeBlock} = options);
      content = [];
      if (canStartHead(token)) {
        content.push(parseHead(canBeBlock));
      } else if (mustBeHead) {
        throw 'bad expression';
      } else {
        content.push({
          type: 'head',
          content: [
            {
              type: 'name',
              content: '&'
            }
          ]
        });
      }
      while (true) {
        if (token.content === '::') {
          content.push(parsePipeAssign());
        } else if (token.type === 'dotName') {
          content.push(parsePipeCall(canBeBlock));
        } else if (token.type === 'biOp') {
          content.push(parsePipeOp(canBeBlock));
        } else if (token.type === 'pipe') {
          parseTerminal();
          if (token.type === 'name' && token.content.match(/^[^!@&]+$/)) {
            token.type = 'dotName';
            token.content = '.' + token.content;
          }
          if ((ref = token.type) !== 'dotName' && ref !== 'biOp') {
            throw 'bad pipe';
          }
        } else if (token.type === 'newline') {
          //log endExpr
          //break if endExpr
          if ((ref1 = nextToken != null ? nextToken.type : void 0) === 'dotName' || ref1 === 'biOp') {
            parseTerminal();
          } else {
            break;
          }
        } else {
          break;
        }
      }
      // handle update assignment
      handleUpdate(content);
      return {
        type: 'expr',
        content
      };
    };
    handleUpdate = function(expr) {
      var elem, i, len, ref, ref1, results, seg;
      seg = expr[0];
      if (seg.type !== 'head') {
        return;
      }
      ref = seg.content;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        elem = ref[i];
        if ((ref1 = elem.content) === 'yield' || ref1 === 'await') {
          continue;
        }
        if ((elem.type === 'name') && (elem.content.endsWith('!'))) {
          expr.push({
            type: 'pipeAssign',
            content: [elem]
          });
        }
        break;
      }
      return results;
    };
    parseHead = function(canBeBlock) {
      var a, content, ref, ref1, ref2, ref3, ref4, ref5;
      endExpr = false;
      content = [];
      while ((ref = token.content) === 'await' || ref === 'yield') {
        content.push(parseTerminal());
      }
      if ((content.length > 0) && (ref1 = token.type, indexOf.call(valueTypes, ref1) < 0)) {
        throw 'bad await/yield';
      }
      if (ref2 = token.type, indexOf.call(blockTypes, ref2) >= 0) {
        endExpr = true;
      }
      if (token.type === 'tag') {
        content.push(...(parseTag()));
      } else {
        content.push(parseValue({
          canBeUpdate: true,
          canBeBlock
        }));
      }
      while (true) {
        if (ref3 = token.type, indexOf.call(valueTypes, ref3) >= 0) {
          if (ref4 = token.type, indexOf.call(blockTypes, ref4) >= 0) {
            endExpr = true;
          }
          content.push(parseValue({
            canBeUpdate: false,
            canBeBlock
          }));
        } else if (token.type === 'wave') {
          a = content.at(-2);
          if (a && ((ref5 = a.content) !== 'await' && ref5 !== 'yield')) {
            throw 'bad ~';
          }
          content.push(parseTerminal());
          break;
        } else if (token.type === 'indent' && canBeBlock) {
          endExpr = true;
          content.push(parseArgBlock());
        } else if (token.type === 'key') {
          content.push(parseObject(canBeBlock));
        } else {
          break;
        }
      }
      return {
        type: 'head',
        content
      };
    };
    parsePipeCall = function(canBeBlock) {
      var content, ref, ref1;
      content = [];
      content.push(parseTerminal());
      while (true) {
        if (ref = token.type, indexOf.call(valueTypes, ref) >= 0) {
          if (ref1 = token.type, indexOf.call(blockTypes, ref1) >= 0) {
            endExpr = true;
          }
          content.push(parseValue({
            canBeUpdate: false,
            canBeBlock
          }));
        } else if (token.type === 'indent' && canBeBlock) {
          endExpr = true;
          content.push(parseArgBlock());
        } else if (token.type === 'key') {
          content.push(parseObject(canBeBlock));
        } else {
          break;
        }
      }
      return {
        type: 'pipeCall',
        content
      };
    };
    parsePipeOp = function(canBeBlock) {
      var content, ref, ref1;
      content = [];
      content.push(parseTerminal());
      while (true) {
        if (ref = token.type, indexOf.call(valueTypes, ref) >= 0) {
          if (ref1 = token.type, indexOf.call(blockTypes, ref1) >= 0) {
            endExpr = true;
          }
          content.push(parseValue({
            canBeUpdate: false,
            canBeBlock
          }));
        } else {
          //else if token.type is 'indent' and canBeBlock
          //    endExpr = true
          //    content.push parseArgBlock()
          break;
        }
      }
      return {
        type: 'pipeOp',
        content
      };
    };
    parseObject = function(canBeBlock) {
      var content, name, ref, ref1;
      content = [];
      while (token.type === 'key') {
        if (token.content.endsWith(';')) {
          name = token.content.slice(0, -1);
          token.content = name + ':';
          content.push(parseTerminal());
          content.push({
            type: 'name',
            content: name
          });
          continue;
        }
        content.push(parseTerminal());
        if (ref = token.type, indexOf.call(valueTypes, ref) < 0) {
          throw 'bad value';
        }
        if (ref1 = token.type, indexOf.call(blockTypes, ref1) >= 0) {
          endExpr = true;
        }
        if ((token.type === 'name') && (token.content.startsWith('~'))) {
          throw 'bad spread';
        }
        content.push(parseValue({
          canBeUpdate: false,
          canBeBlock
        }));
      }
      return {
        type: 'object',
        content
      };
    };
    parseParen = function() {
      var res;
      parseTerminal();
      if (!canStartHead(token)) {
        throw '(bad)';
      }
      res = parseExpression({
        mustBeHead: true,
        canBeBlock: false
      });
      if (token.type !== 'closeParen') {
        throw 'missing paren';
      }
      parseTerminal();
      return res;
    };
    hasArguments = function() {
      var idx2;
      idx2 = idx - 1;
      while (true) {
        if (tokenStream[idx2].type === 'comma') {
          return true;
        }
        if (!isParamName(tokenStream[idx2])) {
          return false;
        }
        idx2++;
      }
    };
    parseLineFunction = function() {
      var content, ref, type;
      content = [];
      content.push({
        type: 'resWord',
        content: ''
      });
      type = token.type;
      parseTerminal();
      //throw 'bad comma' if token.type is 'comma'
      if (hasArguments()) {
        while (token.type !== 'comma') {
          if (token.content.startsWith('~')) {
            if ((nextToken != null ? nextToken.type : void 0) !== 'comma') {
              throw 'bad soak';
            }
          }
          content.push(parseTerminal());
        }
        parseTerminal();
      }
      if ((canStartHead(token)) || ((ref = token.type) === 'biOp' || ref === 'dotName')) {
        content.push(parseExpression({
          mustBeHead: false,
          canBeBlock: false
        }));
      } else {
        content.push({
          type: 'empty',
          content: ''
        });
      }
      if (type === 'openCurly') {
        if (token.type !== 'closeCurly') {
          //logs token unless token.type is 'closeCurly'
          throw 'missing curly';
        }
        parseTerminal();
      }
      return handleAwaitYield({
        type: 'lineFunction',
        content
      });
    };
    parseStringInterp = function() {
      var content;
      content = [];
      content.push(parseTerminal());
      while (true) {
        if (!canStartHead(token)) {
          throw '[bad]';
        }
        content.push(parseExpression({
          mustBeHead: true,
          canBeBlock: false
        }));
        if (token.type === 'stringMiddle') {
          content.push(parseTerminal());
        } else if (token.type === 'stringEnd') {
          content.push(parseTerminal());
          break;
        } else {
          throw '[bad]';
        }
      }
      return {
        type: 'stringInterp',
        content
      };
    };
    //#####################################################################################
    canStartHead = function(token) {
      var a, b, ref, ref1;
      a = (ref = token.type, indexOf.call(valueTypes, ref) >= 0);
      b = (ref1 = token.content) === 'await' || ref1 === 'yield';
      return a || b;
    };
    handleAwaitYield = function(node) {
      var foundAwait, foundYield, kw, recFunc;
      foundAwait = false;
      foundYield = false;
      recFunc = function(node) {
        var i, len, ref, ref1, results, subNode;
        ref = node.content;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          subNode = ref[i];
          if (subNode.content === 'await') {
            foundAwait = true;
          }
          if (subNode.content === 'yield') {
            foundYield = true;
          }
          if ((ref1 = subNode.type) === 'def' || ref1 === 'blockFunc' || ref1 === 'thinArrow' || ref1 === 'curly') {
            continue;
          }
          if (!Array.isArray(subNode.content)) {
            continue;
          }
          results.push(recFunc(subNode));
        }
        return results;
      };
      recFunc(node);
      kw = 'function';
      if (foundAwait) {
        kw = 'async ' + kw;
      }
      if (foundYield) {
        kw = kw + '*';
      }
      node.content[0].content = kw;
      return node;
    };
    handleScope = function(node) {
      var outers, recFunc, vars;
      vars = [];
      outers = [];
      recFunc = function(node) {
        var i, j, k, l, len, len1, len2, len3, ref, results, subNode, subNodes;
        if (isString(node.content)) {
          return;
        }
        if ((ref = node.type) === 'def' || ref === 'blockFunc') {
          return;
        }
        subNodes = node.content;
        if (node.type === 'pipeAssign') {
          if (isString(subNodes[0].content)) {
            if (!subNodes[0].content.endsWith('!')) {
              vars.push(subNodes[0].content);
            }
          }
        }
        if (node.type === 'destruct') {
          for (i = 0, len = subNodes.length; i < len; i++) {
            subNode = subNodes[i];
            if (isString(subNode.content)) {
              vars.push(subNode.content);
            }
          }
        }
        if (node.type === 'let') {
          if (isString(subNodes[0].content)) {
            vars.push(subNodes[0].content);
          }
        }
        if (node.type === 'for') {
          vars.push(subNodes[0].content);
          if (isSimpleName(subNodes[1])) {
            vars.push(subNodes[1].content);
          }
        }
        if (node.type === 'var') {
          for (j = 0, len1 = subNodes.length; j < len1; j++) {
            subNode = subNodes[j];
            vars.push(subNode.content);
          }
        }
        if (node.type === 'outer') {
          for (k = 0, len2 = subNodes.length; k < len2; k++) {
            subNode = subNodes[k];
            outers.push(subNode.content);
          }
        }
        results = [];
        for (l = 0, len3 = subNodes.length; l < len3; l++) {
          subNode = subNodes[l];
          results.push(recFunc(subNode));
        }
        return results;
      };
      recFunc(node);
      vars = vars.filter(function(name) {
        return (indexOf.call(outers, name) < 0) && (name.match(/^:?[^@&:?]*$/));
      });
      vars = vars.map(function(name) {
        if (name.startsWith(':')) {
          name = name.slice(1);
        }
        if (name.endsWith('?')) {
          name = name.slice(0, -1);
        }
        return name;
      });
      if (vars.length === 0) {
        return node;
      }
      node.content.unshift({
        type: 'scope',
        content: 'var ' + vars.join(',')
      });
      return node;
    };
    checkName = function(tok, regex) {
      var a, b, ref;
      a = (ref = tok.type) === 'name' || ref === 'dotName';
      b = tok.content.match(regex);
      return a && b;
    };
    isVarName = function(tok) {
      return checkName(tok, /^[^~!]*$/);
    };
    isParamName = function(tok) {
      return checkName(tok, /^~?[a-zA-Z_$][a-zA-Z0-9_$]*$/);
    };
    isSimpleName = function(tok) {
      return checkName(tok, /^[a-zA-Z_$][a-zA-Z0-9_$]*$/);
    };
    isDestructName = function(tok) {
      return checkName(tok, /^[:~]?[a-zA-Z_$][a-zA-Z0-9_$]*$/);
    };
    parsePipeAssign = function() { //throw 'unimplemented'
      var content;
      parseTerminal();
      content = [];
      if (isVarName(token)) {
        content.push(parseTerminal());
      } else if (token.type === 'openParen') {
        content.push(parseDestruct());
      } else {
        throw 'parsePipeAssign';
      }
      return {
        type: 'pipeAssign',
        content
      };
    };
    parseDestruct = function() {
      var content, type;
      content = [];
      parseTerminal();
      type = null;
      while (isDestructName(token)) {
        if (type && (token.type !== type)) {
          throw 'parseDestruct';
        } else {
          type = token.type;
        }
        content.push(parseTerminal());
      }
      if (!(content.length > 0)) {
        throw 'parseDestruct';
      }
      if (token.type !== 'closeParen') {
        throw 'parseDestruct';
      }
      parseTerminal();
      return {
        type: 'destruct',
        content
      };
    };
    parseFatArrow = function() {
      var content;
      content = [];
      content.push(parseTerminal());
      while (isParamName(token)) {
        if (token.content.startsWith('~')) {
          if ((nextToken != null ? nextToken.type : void 0) !== 'indent') {
            throw 'bad soak';
          }
        }
        content.push(parseTerminal());
      }
      if (token.type !== 'indent') {
        throw 'missing block';
      }
      content.push(handleScope(parseStatementBlock()));
      return handleAwaitYield({
        type: 'blockFunc',
        content
      });
    };
    parseDef = function() {
      var content;
      content = [];
      content.push(parseTerminal());
      if (token.type !== 'name') {
        throw 'bad func name';
      }
      content.push(parseTerminal());
      while (isParamName(token)) {
        if (token.content.startsWith('~')) {
          if ((nextToken != null ? nextToken.type : void 0) !== 'indent') {
            throw 'bad soak';
          }
        }
        content.push(parseTerminal());
      }
      if (token.type !== 'indent') {
        throw 'missing block';
      }
      content.push(handleScope(parseStatementBlock()));
      return handleAwaitYield({
        type: 'def',
        content
      });
    };
    //#####################################################################################
    parseStatementBlock = function() {
      var content, ref, ref1, ref2;
      content = [
        {
          type: 'var',
          content: [
            {
              type: 'name',
              content: '_'
            }
          ]
        }
      ];
      if (token.type === 'indent') {
        parseTerminal();
      }
      while (true) {
        //if token.type is 'newline'
        //    parseTerminal()
        if (isAssignment()) {
          content.push(parseLet());
        } else if (token.content === 'return') {
          content.push(parseReturn());
        } else if (token.content === 'throw') {
          content.push(parseThrow());
        } else if (token.content === 'try') {
          content.push(parseTry());
        } else if (token.content === 'opt') {
          content.push(parseOpt());
        } else if (token.content === 'def') {
          content.push(parseDef());
        } else if (token.content === 'while') {
          content.push(parseWhile());
        } else if (token.content === 'for') {
          content.push(parseFor());
        } else if ((ref = token.content) === 'var' || ref === 'outer') {
          content.push(parseDeclaration());
        } else if ((ref1 = token.content) === 'if' || ref1 === 'unless') {
          content.push(parseConditional());
        } else if ((ref2 = token.content) === 'break' || ref2 === 'continue') {
          content.push(parseLoopControl());
        } else if (canStartHead(token)) {
          content.push(parseExpression({
            mustBeHead: true,
            canBeBlock: true
          }));
        } else if (token.type === 'dedent') {
          parseTerminal();
          break;
        }
        if (token.type === 'newline') {
          parseTerminal();
        } else if (token.type === 'EOF') {
          break;
        } else {
          throw 'bad statement: ' + token.type;
        }
      }
      return {
        type: 'statementBlock',
        content
      };
    };
    parseTry = function() {
      var catchContent, content;
      content = [];
      parseTerminal();
      if (token.type !== 'indent') {
        throw 'try';
      }
      content.push({
        type: 'try',
        content: [parseStatementBlock()]
      });
      if ((nextToken != null ? nextToken.content : void 0) === 'catch') {
        catchContent = [];
        if (token.type === 'newline') {
          parseTerminal();
        } else {
          throw 'catch';
        }
        parseTerminal();
        if (isSimpleName(token)) {
          catchContent.push(parseTerminal());
        }
        if (token.type !== 'indent') {
          throw 'catch';
        }
        catchContent.push(parseStatementBlock());
        content.push({
          type: 'catch',
          content: catchContent
        });
      }
      if ((nextToken != null ? nextToken.content : void 0) === 'finally') {
        if (token.type === 'newline') {
          parseTerminal();
        } else {
          throw 'finally';
        }
        parseTerminal();
        if (token.type !== 'indent') {
          throw 'finally';
        }
        content.push({
          type: 'finally',
          content: [parseStatementBlock()]
        });
      }
      if (content.length < 2) {
        throw 'missing catch/finally';
      }
      return {
        type: 'TCF',
        content
      };
    };
    parseLoopControl = function() {
      var content;
      content = [];
      content.push(parseTerminal());
      if (token.type === 'name') {
        content.push(parseTerminal());
      }
      return {
        type: 'loopControl',
        content
      };
    };
    parseDeclaration = function() {
      var content, type;
      content = [];
      type = token.content;
      parseTerminal();
      while (isSimpleName(token)) {
        content.push(parseTerminal());
      }
      return {type, content};
    };
    parseConditional = function() {
      var content, ref, type;
      content = [];
      type = token.content;
      parseTerminal();
      if (!canStartHead(token)) {
        throw 'expression expected';
      }
      content.push(parseExpression({
        mustBeHead: true,
        canBeBlock: false
      }));
      if (token.type === 'newline') {
        parseTerminal();
      }
      if (isAssignment()) {
        content.push(parseLet());
      } else if (token.content === 'return') {
        content.push(parseReturn());
      } else if (token.content === 'throw') {
        content.push(parseThrow());
      } else if (token.content === 'def') {
        content.push(parseDef());
      } else if (token.content === 'while') {
        content.push(parseWhile());
      } else if (token.content === 'for') {
        content.push(parseFor());
      } else if ((ref = token.content) === 'break' || ref === 'continue') {
        content.push(parseTerminal());
      } else if (token.content === 'do') {
        parseTerminal();
        if (!canStartHead(token)) {
          throw 'parseContitional';
        }
        content.push(parseExpression({
          mustBeHead: true,
          canBeBlock: true
        }));
      }
      return {type, content};
    };
    parseFor = function() {
      var content, ref;
      content = [];
      parseTerminal();
      if (!isSimpleName(token)) {
        throw 'name expected';
      }
      content.push(parseTerminal());
      if (isSimpleName(token)) {
        content.push(parseTerminal());
      }
      if ((ref = token.content) !== 'in' && ref !== 'of') {
        throw 'in/of expected';
      }
      content.push(parseTerminal());
      if (!canStartHead(token)) {
        throw 'expression expected';
      }
      content.push(parseExpression({
        mustBeHead: true,
        canBeBlock: false
      }));
      if (token.type === 'label') {
        content.push(parseTerminal());
      }
      if (token.type !== 'indent') {
        throw 'missing block';
      }
      content.push(parseStatementBlock());
      return {
        type: 'for',
        content
      };
    };
    parseWhile = function() {
      var content;
      content = [];
      parseTerminal();
      if (!canStartHead(token)) {
        throw 'expression expected';
      }
      content.push(parseExpression({
        mustBeHead: true,
        canBeBlock: false
      }));
      if (token.type === 'label') {
        content.push(parseTerminal());
      }
      if (token.type !== 'indent') {
        throw 'missing block';
      }
      content.push(parseStatementBlock());
      return {
        type: 'while',
        content
      };
    };
    parseOpt = function() {
      var content, ref;
      content = [];
      while (true) {
        if ((token.content === 'alt') && ((nextToken != null ? nextToken.content : void 0) === 'default')) {
          parseTerminal();
          parseTerminal();
          if (token.type !== 'indent') {
            throw 'missing block';
          }
          content.push(parseStatementBlock());
          break;
        }
        parseTerminal();
        if (!canStartHead(token)) {
          throw 'expression expected';
        }
        content.push(parseExpression({
          mustBeHead: true,
          canBeBlock: false
        }));
        if (token.type !== 'indent') {
          throw 'missing block';
        }
        content.push(parseStatementBlock());
        if ((ref = token.type) !== 'newline' && ref !== 'EOF') {
          throw 'wha??';
        }
        if ((nextToken != null ? nextToken.content : void 0) === 'alt') {
          parseTerminal();
        } else {
          break;
        }
      }
      return {
        type: 'opt',
        content
      };
    };
    isAssignment = function() {
      var idx2, ref;
      idx2 = idx - 1;
      while (true) {
        if (tokenStream[idx2].content === '=') {
          return true;
        }
        if ((ref = tokenStream[idx2].type) !== 'name' && ref !== 'openParen' && ref !== 'closeParen') {
          return false;
        }
        idx2++;
      }
    };
    parseLet = function() {
      var content;
      content = [];
      //parseTerminal()
      if (isVarName(token)) {
        content.push(parseTerminal());
      } else if (token.type === 'openParen') {
        content.push(parseDestruct());
      } else {
        throw 'parseLet';
      }
      if (token.content !== '=') {
        throw '= expected';
      }
      parseTerminal();
      if (!canStartHead(token)) {
        throw 'value expected';
      }
      content.push(parseExpression({
        mustBeHead: true,
        canBeBlock: true
      }));
      return {
        type: 'let',
        content
      };
    };
    parseReturn = function() {
      var content;
      content = [];
      parseTerminal();
      if (canStartHead(token)) {
        content.push(parseExpression({
          mustBeHead: true,
          canBeBlock: true
        }));
      }
      return {
        type: 'return',
        content
      };
    };
    parseThrow = function() {
      var content;
      content = [];
      parseTerminal();
      if (canStartHead(token)) {
        content.push(parseExpression({
          mustBeHead: true,
          canBeBlock: true
        }));
      }
      return {
        type: 'throw',
        content
      };
    };
    parseArgBlock = function() {
      var content;
      content = [];
      parseTerminal();
      while (true) {
        if (canStartHead(token)) {
          content.push(parseExpression({
            mustBeHead: true,
            canBeBlock: true
          }));
          if (token.type !== 'newline') {
            throw 'bad argument: ' + token.type;
          }
        } else if (token.type === 'key') {
          content.push(parseObjectBlock());
        } else if (token.type === 'newline') {
          parseTerminal();
        } else if (token.type === 'dedent') {
          parseTerminal();
          break;
        } else if (token.type === 'EOF') {
          break;
        } else {
          throw 'bad argument';
        }
      }
      return {
        type: 'argBlock',
        content
      };
    };
    parseObjectBlock = function() {
      var content, name;
      content = [];
      while (token.type === 'key') {
        if (token.content.endsWith(';')) {
          name = token.content.slice(0, -1);
          token.content = name + ':';
          content.push(token); // too hacky?
          token = {
            type: 'name',
            content: name // too hacky?
          };
        } else {
          // instead: push (expression (head (name)))?
          content.push(parseTerminal());
        }
        if (!canStartHead(token)) {
          log(token);
          throw 'bad value';
        }
        content.push(parseExpression({
          mustBeHead: true,
          canBeBlock: true
        }));
        if (token.type !== 'newline') {
          throw 'bad value: ' + token.type;
        }
        parseTerminal();
      }
      return {
        type: 'object',
        content
      };
    };
    makeStrict = function(block) {
      block.content.unshift({
        type: 'string',
        content: '~> use strict'
      });
      return block;
    };
    return makeStrict(handleScope(parseStatementBlock()));
  };

  //#########################################################################################
  pVal = '_';

  isString = function(x) {
    return typeof x === 'string';
  };

  isArray = function(x) {
    return Array.isArray(x);
  };

  translate = function(node) {
    var i, len, ref, subNode, subNodes;
    if (isString(node.content)) {
      if (generate[node.type]) {
        return generate[node.type](node.content);
      } else {
        return node.content;
      }
    }
    if (isArray(node.content)) {
      subNodes = [];
      ref = node.content;
      for (i = 0, len = ref.length; i < len; i++) {
        subNode = ref[i];
        subNodes.push(translate(subNode));
      }
      if (!generate[node.type]) {
        throw "can't translate " + node.type;
      }
      return generate[node.type](subNodes);
    }
    logs(node);
    throw 'no content?';
  };

  generate = {
    statementBlock: function(subNodes) {
      return subNodes.join(';');
    },
    expr: function(subNodes) {
      var sn;
      sn = subNodes.map(function(x) {
        return pVal + '=' + x;
      });
      sn[sn.length - 1] = subNodes[subNodes.length - 1];
      return `(${sn.join(',')})`;
    },
    head: function(subNodes) { //subNodes.join ', '
      var exp, i, len, r, ref, ref1, rs, x, xs;
      rs = [];
      while ((ref = subNodes[0]) === 'await' || ref === 'yield') {
        rs.push(subNodes.shift());
      }
      x = subNodes[0];
      xs = subNodes.slice(1);
      if (xs.length === 0) {
        exp = x;
      } else {
        exp = x + '(' + xs + ')';
      }
      ref1 = rs.reverse();
      for (i = 0, len = ref1.length; i < len; i++) {
        r = ref1[i];
        exp = `(${r} ${exp})`;
      }
      return exp;
    },
    pipeOp: function(subNodes) {
      var op;
      op = subNodes[0];
      if (op === '') {
        return "do stuff";
      }
      return [pVal, op, subNodes[1]].join('');
    },
    biOp: function(content) {
      if (content === "is") {
        return "===";
      }
      if (content === "==") {
        return "===";
      }
      if (content === "is not") {
        return "!==";
      }
      if (content === "!=") {
        return "!==";
      }
      //return "" if content is ""
      //return "" if content is ""
      //return "" if content is ""
      return content;
    },
    pipeAssign: function(subNodes) {
      var name;
      name = subNodes[0].replaceAll('?.', '.');
      if (name.endsWith('?')) {
        name = name.slice(0, -1);
        return `(${name} != null ? ${name} : ${name} = ${pVal})`;
      }
      return `${name}=${pVal}`;
    },
    let: function(subNodes) {
      var expr, name;
      name = subNodes[0].replaceAll('?.', '.');
      expr = subNodes[1];
      if (name.endsWith('?')) {
        name = name.slice(0, -1);
        return `(${name} != null ? ${name} : ${name} = ${expr})`;
      }
      return `${name}=${expr}`;
    },
    return: function(subNodes) {
      return ["return", ...subNodes].join(' ');
    },
    throw: function(subNodes) {
      return ["throw", ...subNodes].join(' ');
    },
    pipeCall: function(subNodes) {
      var args, func, type;
      //log subNodes
      func = subNodes[0];
      args = subNodes.slice(1);
      type = (func[0] === ':' ? 'method' : 'function');
      func = func.slice(1).replaceAll(':', '?.');
      if (type === 'method') {
        return `${pVal}.${func}(${args.join(',')})`;
      }
      if (type === 'function') {
        args.unshift(pVal);
        return `${func}(${args.join(',')})`;
      }
      throw 'e.259';
    },
    name: function(content) {
      var res;
      res = content;
      res = res.replaceAll(':', '?.');
      res = res.replace('@', 'this.');
      res = res.replace('&&', 'arguments');
      res = res.replace(/^&([0-9]+)/, 'arguments[$1]');
      res = res.replace(/^&([^.]+)/, 'arguments[0].$1');
      res = res.replace('&', 'arguments[0]');
      res = res.replace('~', '...');
      return res.replace('!', '');
    },
    bool: function(content) {
      return content;
    },
    number: function(content) {
      return content;
    },
    dotName: function(content) {
      return content;
    },
    resWord: function(content) {
      return content;
    },
    string: function(content) {
      if (content.startsWith('"')) {
        return content;
      }
      if (content.startsWith("'")) {
        return content + "'";
      }
      return JSON.stringify(content.slice(2).trim());
    },
    stringStart: function(content) {
      return content.slice(0, -1) + '"';
    },
    stringMiddle: function(content) {
      return '"' + content.slice(1, -1) + '"';
    },
    stringEnd: function(content) {
      return '"' + content.slice(1);
    },
    wave: function(content) {
      return '';
    },
    stringInterp: function(content) {
      return '(' + (content.join('+')) + ')';
    },
    blockFunc: function(content) {
      var args, block, kw;
      kw = content[0];
      args = content.slice(1, -1);
      block = content.at(-1);
      return `${kw}(${args.join(',')}){${block}}`;
    },
    def: function(content) {
      var args, block, kw, name;
      kw = content[0];
      name = content[1];
      args = content.slice(2, -1);
      block = content.at(-1);
      return `${kw} ${name}(${args.join(',')}){${block}}`;
    },
    lineFunction: function(sn) {
      return `${sn[0]}(${sn.slice(1, -1).join(',')}){var _;return ${sn.at(-1)}}`;
    },
    opt: function(content) {
      var a, b, idx, res;
      res = [];
      idx = 0;
      while (true) {
        a = content[idx++];
        b = content[idx++];
        if (!(a && b)) {
          break;
        }
        res.push(`if(${a}){${b}}`);
      }
      res = res.join('else ');
      if (a) {
        res += `else{${a}}`;
      }
      return res;
    },
    while: function(content) {
      var label;
      if (content.at(-2).match('^[a-zA-Z_$]+:$')) {
        label = content.at(-2);
      } else {
        label = '';
      }
      return `${label}while(${content[0]}){${content.at(-1)}}`;
    },
    for: function(content) {
      var block, expr, kw, label, nameA, nameB;
      nameA = content[0];
      nameB = content[1];
      kw = content.at(-3);
      expr = content.at(-2);
      block = content.at(-1);
      label = '';
      if (content.at(-2).match('^[a-zA-Z_$]+:$')) {
        kw = content.at(-4);
        expr = content.at(-3);
        label = content.at(-2);
      }
      if (nameB !== 'in' && nameB !== 'of') {
        if (kw === 'in') {
          block = `${nameB}++;` + block;
          expr = `((${nameB}=-1),` + expr + ')';
        } else {
          block = `${nameB}=_ref[${nameA}];` + block;
          expr = '_ref = ' + expr + '';
        }
      }
      if (kw === 'in') {
        kw = 'of';
      } else {
        kw = 'in';
      }
      return `${label}for(${nameA} ${kw} ${expr}){${block}}`;
    },
    if: function(content) {
      return `if(${content[0]}){${content[1]}}`;
    },
    unless: function(content) {
      return `if(not ${content[0]}){${content[1]}}`;
    },
    var: function() {
      return '';
    },
    outer: function() {
      return '';
    },
    destruct: function(content) {
      var names;
      if (content[0].startsWith(':')) {
        names = content.map(function(name) {
          return name.slice(1);
        });
      } else {
        names = content;
      }
      if (content[0].startsWith(':')) {
        return "{" + names.join(',') + "}";
      } else {
        return "[" + names.join(',') + "]";
      }
    },
    object: function(content) {
      content;
      var res;
      res = content.join(',');
      res = res.replaceAll(':,', ':');
      return '{' + res + '}';
    },
    argBlock: function(content) {
      return content.join(',');
    },
    label: function(content) {
      return content.slice(1, -1) + ':';
    },
    loopControl: function(content) {
      return content.join(' ');
    },
    TCF: function(content) {
      return content.join('');
    },
    try: function(content) {
      return `try{${content}}`;
    },
    catch: function(c) {
      if (c.length === 1) {
        return `catch{${c[0]}}`;
      } else {
        return `catch(${c[0]}){${c[1]}}`;
      }
    },
    finally: function(content) {
      return `finally{${content}}`;
    }
  };

  //generate.statementBlock ast

  //#########################################################################################
  seacow = {tokenize, parse, translate};

  if (typeof module !== "undefined" && module !== null) {
    module.exports = seacow;
  } else {
    globalThis.seacow = seacow;
  }

  //#########################################################################################

  // code | tokenize | parse | translate | format
/*

TODO:
X handle complex:names
X handle ~soak and ~spread
X handle key;
X handle {args, ...}
X check @x, &1, &x, &, &&

X labels
X try / catch / finally
X throw

no 'new' operator. use Reflect.construct instead.

classes?

class foo extends bar

    def constructor a b
        ...

    def baz c d
        ...

----

  global foo bar baz

*/

}).call(this);
